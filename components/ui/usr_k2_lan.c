// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.1
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "nvs_flash.h"
#include "esp_log.h"
#include "esp_netif.h"
#include "driver/uart.h"
#include "string.h"
#include "usr_k2_lan.h"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include "my_global_lib.h"
#include "../ui/ui.h"
#include "../ui/safe_page.h"
#include "nvs_helper.h"
#include "transaction.h"

#define USRK2LAN_UART_NUM UART_NUM_2
#define BUF_SIZE 1024
#define RESPONSE_TIMEOUT_MS 10000 // Timeout 10 detik

// UART 2
#define GPIO_NUM_17 17 // tx
#define GPIO_NUM_16 16 // rx
#define UART_BUFFER_SIZE 1024

/* Global Structure Start */
/* Global Structure End */

/* End prototype function main program */

//static const char *TAG = "USR_K2_LAN";

static EventGroupHandle_t uart_event_group;
#define UART_RESPONSE_BIT BIT0

// Function untuk handle timeout redirect
static void timeout_redirect_callback(void *param)
{
    // Redirect ke halaman 4 terlebih dahulu
    go_page4(NULL);
    
    // Update label setelah halaman 4 dimuat (gunakan delay kecil)
    // Atau bisa diupdate langsung di halaman 4 melalui callback
    DEBUG_PRINTLN("LAN request timeout - redirected to page 4");
}

void usr_k2_init(void)
{
    uart_event_group = xEventGroupCreate(); // Inisialisasi Event Group
    init_uart();
}

void init_uart(void)
{
    // Flush any existing data first
    uart_flush(USRK2LAN_UART_NUM);
    
    const uart_config_t uart_config = {
        .baud_rate = 115200,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 122, // Default threshold
    };

    // Install driver UART with larger buffer and event queue
    esp_err_t ret = uart_driver_install(USRK2LAN_UART_NUM, BUF_SIZE * 2, BUF_SIZE * 2, 10, NULL, 0);
    if (ret != ESP_OK) {
        DEBUG_PRINTLN("UART driver install failed: %d", ret);
        return;
    }
    
    ret = uart_param_config(USRK2LAN_UART_NUM, &uart_config);
    if (ret != ESP_OK) {
        DEBUG_PRINTLN("UART param config failed: %d", ret);
        return;
    }

    // Set UART pins
    ret = uart_set_pin(USRK2LAN_UART_NUM, GPIO_NUM_17, GPIO_NUM_16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    if (ret != ESP_OK) {
        DEBUG_PRINTLN("UART set pin failed: %d", ret);
        return;
    }
    
    // Clear any pending data
    uart_flush(USRK2LAN_UART_NUM);
    
    xTaskCreate(uart_read_response, "uart_read_response", 8192, NULL, 10, NULL);

    DEBUG_PRINTLN("Load USR-k2-LAN successfully");
}

// Modifikasi send_at_command dengan timeout
bool send_at_command(const char *msg)
{
    if (msg == NULL || strlen(msg) == 0 || !is_all_ascii((char *)msg))
    {
        DEBUG_PRINTLN("send_at_command: empty message, not sent.");
        return false;
    }
    else
    {
        // Reset UART sebelum setiap request untuk memastikan komunikasi bersih
        DEBUG_PRINTLN("Resetting UART before command...");
        uart_flush(USRK2LAN_UART_NUM);
        vTaskDelay(pdMS_TO_TICKS(100)); // Delay lebih lama untuk UART settle
        
        // Clear any buffered data yang mungkin tersisa
        size_t buffered_size = 0;
        uart_get_buffered_data_len(USRK2LAN_UART_NUM, &buffered_size);
        if (buffered_size > 0) {
            DEBUG_PRINTLN("Clearing %d bytes of buffered data", buffered_size);
            uint8_t temp_buffer[128];
            uart_read_bytes(USRK2LAN_UART_NUM, temp_buffer, sizeof(temp_buffer), 0);
        }
        
        char buffer_command[256];
        snprintf(buffer_command, sizeof(buffer_command), "%s\r\n", msg);

        // Bersihkan event sebelum kirim
        xEventGroupClearBits(uart_event_group, UART_RESPONSE_BIT);

        uart_write_bytes(USRK2LAN_UART_NUM, buffer_command, strlen(buffer_command));
        DEBUG_PRINTLN("Sent: %s", buffer_command);

        // Tunggu respons
        EventBits_t bits = xEventGroupWaitBits(
            uart_event_group,
            UART_RESPONSE_BIT,
            pdTRUE,
            pdFALSE,
            pdMS_TO_TICKS(RESPONSE_TIMEOUT_MS)
        );

        if ((bits & UART_RESPONSE_BIT) == 0)
        {
            DEBUG_PRINTLN("UART response timeout! Redirecting to page 4");
            
            // Flush UART on timeout untuk membersihkan data corrupt
            uart_flush(USRK2LAN_UART_NUM);
            
            // Update label dengan pesan "request gagal" dan redirect ke halaman 4
            lv_async_call(timeout_redirect_callback, NULL);
            
            return false;
        }
        return true;
    }
}

void uart_read_response(void *arg)
{
    uint8_t data[BUF_SIZE];
    int consecutive_errors = 0;
    const int MAX_CONSECUTIVE_ERRORS = 3;
    
    while (1)
    {
        // Clear buffer before reading
        memset(data, 0, sizeof(data));
        
        int len = uart_read_bytes(USRK2LAN_UART_NUM, data, sizeof(data) - 1, pdMS_TO_TICKS(500));
        if (len > 0)
        {
            data[len] = '\0'; // Null-terminate the string

            // Additional validation: check for reasonable data length and content
            if (len > 0 && len < BUF_SIZE - 1 && data[0] != '\0')
            {
                // Filter out corrupted data with repeated characters (seperti yang Anda alami)
                bool is_corrupted = false;
                if (len > 10) { // Only check if data is long enough
                    int repeated_count = 0;
                    for (int i = 1; i < len && i < 50; i++) { // Check first 50 chars
                        if (data[i] == data[i-1]) {
                            repeated_count++;
                            if (repeated_count > 8) { // Reduced threshold untuk deteksi lebih sensitif
                                is_corrupted = true;
                                DEBUG_PRINTLN("Detected corruption: too many repeated characters (%c)", data[i]);
                                break;
                            }
                        } else {
                            repeated_count = 0;
                        }
                    }
                }
                
                // Check for specific corruption pattern (0xFF characters yang sering muncul)
                if (!is_corrupted && len > 5) {
                    int ff_count = 0;
                    for (int i = 0; i < len && i < 20; i++) {
                        if (data[i] == 0xFF || data[i] == 0x00 || data[i] == 0xEF) {
                            ff_count++;
                        }
                    }
                    if (ff_count > 3) {
                        is_corrupted = true;
                        DEBUG_PRINTLN("Detected corruption: too many 0xFF/0x00/0xEF bytes (%d)", ff_count);
                    }
                }
                
                if (!is_corrupted && is_all_ascii((char *)data))
                {
                    DEBUG_PRINTLN("Received valid: %s", (char *)data);
                    parse_uart_response((char *)data);

                    // Set event response
                    xEventGroupSetBits(uart_event_group, UART_RESPONSE_BIT);
                    consecutive_errors = 0; // Reset error counter on success
                }
                else
                {
                    consecutive_errors++;
                    DEBUG_PRINTLN("Corrupted or non-ASCII data received (len=%d), error count=%d", len, consecutive_errors);
                    // Print first few bytes for debugging
                    DEBUG_PRINT("First 20 bytes: ");
                    for (int i = 0; i < len && i < 20; i++) {
                        DEBUG_PRINT("%02X ", data[i]);
                    }
                    DEBUG_PRINTLN("");
                    
                    // If too many consecutive errors, flush UART
                    if (consecutive_errors >= MAX_CONSECUTIVE_ERRORS) {
                        DEBUG_PRINTLN("Too many consecutive UART errors, flushing...");
                        uart_flush(USRK2LAN_UART_NUM);
                        vTaskDelay(pdMS_TO_TICKS(50));
                        consecutive_errors = 0;
                    }
                }
            }
            else
            {
                consecutive_errors++;
                DEBUG_PRINTLN("Received empty or invalid UART data (len=%d), error count=%d", len, consecutive_errors);
                
                if (consecutive_errors >= MAX_CONSECUTIVE_ERRORS) {
                    DEBUG_PRINTLN("Too many consecutive UART errors, flushing...");
                    uart_flush(USRK2LAN_UART_NUM);
                    vTaskDelay(pdMS_TO_TICKS(50));
                    consecutive_errors = 0;
                }
            }
        }
    }
}

void parse_uart_response(const char *input)
{
    const char *start = strchr(input, '<');
    const char *end = strrchr(input, '>');

    if (!start || !end || start >= end)
    {
        DEBUG_PRINTLN("Invalid format");
    }
    else
    {

        char buffer[BUF_SIZE];
        size_t len = end - start - 1;
        if (len >= sizeof(buffer))
            len = sizeof(buffer) - 1;

        strncpy(buffer, start + 1, len);
        buffer[len] = '\0';

        // Array untuk menyimpan field
        char fields[MAX_FIELDS][MAX_FIELD_LEN];
        int field = 0;

        char *token = strtok(buffer, "|");
        while (token != NULL && field < MAX_FIELDS)
        {
            strncpy(fields[field], token, MAX_FIELD_LEN - 1);
            fields[field][MAX_FIELD_LEN - 1] = '\0'; // Pastikan null-terminated
            field++;
            token = strtok(NULL, "|");
        }

        if (strcmp(fields[0], "GETINFO") == 0)
        {
            execute_info(fields);
        }
        else if (strcmp(fields[0], "ORDERCHECK") == 0)
        {
            execute_ordercheck(fields);
        }
        else if (strcmp(fields[0], "PAYMENT") == 0)
        {
            execute_payment(fields);
        }
        else if (strcmp(fields[0], "ADDTRANSACTION") == 0)
        {
            execute_addtransaction(fields);
        }
        else
        {
            execute_else();
        }

        // Tampilkan hasil
        // printf("Parsed %d fields:\n", field);
        // for (int i = 0; i < field; i++)
        // {
        //     printf("Field[%d] = %s\n", i, fields[i]);
        // }

        // Contoh akses langsung:
        // printf("Device ID: %s\n", fields[2]);  // Akses index ke-2
    }
}
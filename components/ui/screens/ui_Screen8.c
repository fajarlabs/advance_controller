// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.1
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#include "../ui.h"
#include "../safe_page.h"
#include "../usr_k2_lan.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "lvgl.h"
#include "string.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs_helper.h"
#include "my_global_lib.h"
#include "my_wifi.h"

// Deklarasi fungsi untuk Screen4
extern void screen4_set_message(const char *message);

#define LV_USE_QRCODE CONFIG_LV_USE_QRCODE
#define QR_VERSION 10                   // Maksimal QR version (2-40)
#define QR_ECC_LEVEL ESP_QRCODE_ECC_LOW // Error correction level: Low

//static const char *TAG = "ui_Screen8";

static const int MAX_COUNTDOWN = 90;
static int countdown_time = MAX_COUNTDOWN; // Initial countdown time in seconds
static lv_obj_t *countdown_label = NULL;   // Label to display countdown
static lv_obj_t *qr_code = NULL;

// Add task control variables to prevent memory leak
static volatile bool order_check_task_running = false;
static volatile int active_order_tasks = 0;
#define MAX_CONCURRENT_ORDER_TASKS 2

void load_lv_qrcode();
void update_countdown(lv_timer_t *timer);
void screen8_event_handler(lv_event_t *e);
void order_check_task(void *pvParameters);
void payment_expired_callback(void *param);

lv_timer_t *my_timer;

// Callback untuk delay set message setelah halaman 4 dimuat
static void delayed_set_message_callback(lv_timer_t *timer)
{
    screen4_set_message("Pembayaran kadaluarsa");
    // Delete timer setelah selesai
    lv_timer_delete(timer);
}

// Callback untuk mengupdate label di halaman 4 dengan pesan pembayaran kadaluarsa
void payment_expired_callback(void *param)
{
    // Redirect ke halaman 4 terlebih dahulu
    go_page4(NULL);
    
    // Set pesan setelah halaman 4 dimuat (dengan delay kecil)
    lv_timer_t *delay_timer = lv_timer_create(delayed_set_message_callback, 100, NULL);
    lv_timer_set_repeat_count(delay_timer, 1); // Sekali saja
    
    DEBUG_PRINTLN("Payment expired - redirected to page 4 with kadaluarsa message");
}

void screen8_event_handler(lv_event_t *e)
{
    lv_event_code_t code = lv_event_get_code(e);

    if (code == LV_EVENT_SCREEN_LOADED)
    {
        // Ini dipanggil setelah screen tampil
        DEBUG_PRINTLN("Screen8 loaded!");

        // Misal kamu mau init timer, init label, dll
        load_lv_qrcode();
    }
    else if (code == LV_EVENT_SCREEN_UNLOADED)
    {
        DEBUG_PRINTLN("Unloading uiScreen 8");

        if (my_timer)
        {
            lv_timer_del(my_timer);
            my_timer = NULL;
        }

        if (qr_code)
        {
            lv_obj_del(qr_code);
            qr_code = NULL;
        }

        if (countdown_label)
        {
            lv_obj_del(countdown_label);
            countdown_label = NULL;
        }

        countdown_time = MAX_COUNTDOWN;
        
        // Reset task control variables
        order_check_task_running = false;
        active_order_tasks = 0;
    }
}

void ui_Screen8_screen_init(void)
{
    ui_Screen8 = lv_obj_create(NULL);
    lv_obj_remove_flag(ui_Screen8, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_add_event_cb(ui_Screen8, screen8_event_handler, LV_EVENT_ALL, NULL);

    ui_Image9 = lv_image_create(ui_Screen8);
    lv_image_set_src(ui_Image9, &ui_img_menerima_semua_payment_yang_dapat_menggunakan_qris_png);
    lv_obj_set_width(ui_Image9, 240);
    lv_obj_set_height(ui_Image9, 320);
    lv_obj_set_align(ui_Image9, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(ui_Image9, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(ui_Image9, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_add_flag(ui_Image9, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_remove_flag(ui_Image9, LV_OBJ_FLAG_SCROLLABLE);
}

// kode program yang lama
// void load_lv_qrcode(void)
// {
//     // =============== LABEL REMAIN =============================================================== /

//     // Create a countdown label
//     if (countdown_label == NULL)
//     {
//         countdown_label = lv_label_create(ui_Screen8);
//     }
//     if (countdown_label != NULL)
//     {
//         lv_label_set_text(countdown_label, "60");                                          // Starting with 60 seconds
//         lv_obj_set_style_text_font(countdown_label, &lv_font_montserrat_22, LV_PART_MAIN); // Set font size to 24
//         lv_obj_align(countdown_label, LV_ALIGN_BOTTOM_MID, 0, -20);                        // Position it above the QR Code label
//     }

//     // Create a timer to update the countdown every 1 second
//     my_timer = lv_timer_create(update_countdown, 1000, NULL); // Update every 1000 ms (1 second)

//     // =============== QRCODE =============================================================== /
//     // Gunakan warna putih dan hitam langsung
//     lv_color_t bg_color = lv_color_white(); // Putih
//     lv_color_t fg_color = lv_color_black(); // Hitam

//     lv_obj_t *qr = lv_qrcode_create(ui_Screen8);
//     lv_qrcode_set_size(qr, 220);
//     lv_qrcode_set_dark_color(qr, fg_color);  // Warna bagian QR code (hitam)
//     lv_qrcode_set_light_color(qr, bg_color); // Warna background QR code (putih)

//     /*Set data*/
//     // const char *long_text = "00020101021226610014COM.GO-JEK.WWW01189360091436216348420210G6216348420303UMI51440014ID.CO.QRIS.WWW0215ID20200175983560303UMI520472995303360540410005802ID5920[VM]-Advance Product6013JAKARTA PUSAT61051061062395028A220250425071103H4hvD0xjMrID0703A016304843F";
//     char bufferQris[300];
//     esp_err_t err1 = load_nvs_str("storage", "QrisImage", bufferQris, sizeof(bufferQris));
//     if (err1 == ESP_OK)
//     {
//         char *long_text = bufferQris;
//         lv_qrcode_update(qr, long_text, strlen(long_text));
//         lv_obj_center(qr);

//         /*Add a border with bg_color*/
//         lv_obj_set_style_border_color(qr, bg_color, 0);
//         lv_obj_set_style_border_width(qr, 5, 0);
//     }
// }

void load_lv_qrcode(void)
{
    // === LABEL COUNTDOWN ===
    if (countdown_label == NULL)
    {
        countdown_label = lv_label_create(ui_Screen8);
        lv_label_set_text(countdown_label, "60");
        lv_obj_set_style_text_font(countdown_label, &lv_font_montserrat_22, LV_PART_MAIN);
        lv_obj_align(countdown_label, LV_ALIGN_BOTTOM_MID, 0, -20);
    }

    // === TIMER ===
    if (my_timer == NULL)
    {
        my_timer = lv_timer_create(update_countdown, 1000, NULL);
    }

    // === QRCODE ===
    // Hapus QR lama jika ada
    if (qr_code != NULL)
    {
        lv_obj_del(qr_code);
        qr_code = NULL;
    }

    lv_color_t bg_color = lv_color_white();
    lv_color_t fg_color = lv_color_black();

    qr_code = lv_qrcode_create(ui_Screen8);
    lv_qrcode_set_size(qr_code, 220);
    lv_qrcode_set_dark_color(qr_code, fg_color);
    lv_qrcode_set_light_color(qr_code, bg_color);

    char bufferQris[300];
    esp_err_t err1 = load_nvs_str("storage", "QrisImage", bufferQris, sizeof(bufferQris));
    if (err1 == ESP_OK)
    {
        lv_qrcode_update(qr_code, bufferQris, strlen(bufferQris));
        lv_obj_center(qr_code);
        lv_obj_set_style_border_color(qr_code, bg_color, 0);
        lv_obj_set_style_border_width(qr_code, 5, 0);
    }
}

void order_check_task(void *pvParameters)
{
    char *order_id = (char *)pvParameters;
    
    // Safety check for null parameter
    if (order_id == NULL) {
        DEBUG_PRINTLN("ERROR: order_check_task received NULL parameter");
        active_order_tasks--;
        order_check_task_running = false;
        vTaskDelete(NULL);
        return;
    }
    
    DEBUG_PRINTLN("Order check task started with order_id: %s (len=%d)", order_id, strlen(order_id));
    
    // Safety check for order_id length to prevent buffer overflow
    if (strlen(order_id) > 80) {
        DEBUG_PRINTLN("ERROR: order_id too long (%d chars), aborting task", strlen(order_id));
        free(order_id);
        active_order_tasks--;
        order_check_task_running = false;
        vTaskDelete(NULL);
        return;
    }
    
    // Increment active task counter
    active_order_tasks++;
    
    // Use larger static buffer to prevent overflow
    static char query_order_check[200]; // Increased from 100 to 200
    memset(query_order_check, 0, sizeof(query_order_check)); // Clear buffer
    
    int written = snprintf(query_order_check, sizeof(query_order_check), "<ORDERCHECK,%s>", order_id);
    
    // Check if snprintf was successful and didn't truncate
    if (written >= sizeof(query_order_check)) {
        DEBUG_PRINTLN("ERROR: query_order_check buffer too small, truncated! written=%d, buffer_size=%d", written, sizeof(query_order_check));
        free(order_id);
        active_order_tasks--;
        order_check_task_running = false;
        vTaskDelete(NULL);
        return;
    }
    
    DEBUG_PRINTLN("Generated order check request: %s (len=%d)", query_order_check, strlen(query_order_check));
    
    int32_t is_wifiorlan = 0;
    const char *nvs_namespace = "storage";
    load_nvs_i32(nvs_namespace, "is_wifiorlan", &is_wifiorlan);
    
    if (is_wifiorlan == NETWORK_LAN) // using LAN
    {
        send_at_command(query_order_check);
    }
    else if (is_wifiorlan == NETWORK_WIFI)
    { // using WiFi
        make_http_request(query_order_check);
    }
    else
    {
        DEBUG_PRINTLN("Network connection not configured (is_wifiorlan = %d)", (int)is_wifiorlan);
    }
    
    // Clean up allocated memory and decrement counter
    DEBUG_PRINTLN("Freeing allocated order_id memory at: %p", order_id);
    free(order_id);
    order_id = NULL; // Set to NULL after free for safety
    
    active_order_tasks--;
    order_check_task_running = false;
    vTaskDelete(NULL);
}

void update_countdown(lv_timer_t *timer)
{
    if (countdown_time > 0)
    {

        if (countdown_time % 2 == 0)
        {
            char bufferOrderId[30];
            esp_err_t err1 = load_nvs_str("storage", "OrderId", bufferOrderId, sizeof(bufferOrderId));
            if (err1 == ESP_OK)
            {
                DEBUG_PRINTLN("Countdown and check midtrans status! : %s", bufferOrderId);
                
                // Prevent task overload - check if too many tasks are running
                if (active_order_tasks < MAX_CONCURRENT_ORDER_TASKS && !order_check_task_running)
                {
                    // Create a copy of order ID for the task (will be freed in task)
                    char *order_id_copy = malloc(strlen(bufferOrderId) + 1);
                    if (order_id_copy != NULL)
                    {
                        strcpy(order_id_copy, bufferOrderId);
                        order_check_task_running = true;
                        
                        // Create task to handle network request without blocking countdown
                        BaseType_t result = xTaskCreate(order_check_task, "order_check_task", 8192, order_id_copy, 5, NULL);
                        if (result != pdPASS)
                        {
                            DEBUG_PRINTLN("Failed to create order check task");
                            free(order_id_copy);
                            order_check_task_running = false;
                        }
                    }
                    else
                    {
                        DEBUG_PRINTLN("Failed to allocate memory for order check task");
                    }
                }
                else
                {
                    DEBUG_PRINTLN("Order check task limit reached or already running, skipping...");
                }
            }
        }

        if (PAYMENT_ROUTE.IsPaymentSuccess)
        {
            DEBUG_PRINTLN("Pembayaran sukses.");
            if (my_timer)
            {
                lv_timer_del(my_timer);
                countdown_time = MAX_COUNTDOWN;
                my_timer = NULL;
            }

            PAYMENT_ROUTE.PaymentType = 2; // qris payment

            lv_async_call(go_page6, NULL);
        }

        countdown_time--;                                             // Decrement countdown time
        char time_text[12];                                           // Buffer with enough space for a 10-digit number + null terminator
        snprintf(time_text, sizeof(time_text), "%d", countdown_time); // Format countdown_time as a string
        if (countdown_label != NULL)
        {
            lv_label_set_text(countdown_label, time_text); // Update label with formatted time
        }

        if (countdown_time < 1)
        {
            DEBUG_PRINTLN("Status pembayaran gagal atau kadaluarsa.");
            if (my_timer)
            {
                lv_timer_del(my_timer);
                countdown_time = MAX_COUNTDOWN;
                my_timer = NULL;
            }
            lv_async_call(payment_expired_callback, NULL);
        }
    }
}